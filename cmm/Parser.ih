// Generated by Bisonc++ V6.01.00 on Wed, 13 Nov 2019 10:25:59 +0300

    // Include this file in the sources of the class Parser.

// $insert class.h
#include "Parser.h"
#include <limits.h>

Parser::Parser(Scanner& scanner, std::ostream& out) : d_scanner(scanner), out(out)
{
    scanner.setSval(&d_val__, &consts, [&](unsigned line, const std::string& str) { nextLine(line, str); });
}

void Parser::error()
{
    throw("Syntax error");
}

// $insert lex
int Parser::lex()
{
    return d_scanner.lex();
}

void Parser::print()
{
    print__();           // displays tokens if --print was specified
}

void Parser::exceptionHandler(std::exception const &exc)
{
    throw;              // re-implement to handle exceptions thrown by actions
}

unsigned Parser::allocString(const std::string& str)
{
    auto i = stringsMap.find(str);
    if (i != stringsMap.end()) return i->second;
    unsigned id = stringCounter++;
    stringsMap[str] = id;
    return id;
}

void Parser::nextLine(unsigned lineNr, const std::string& lineText)
{
    if (!lineText.empty())
        out << "    ; " << lineNr << " " << lineText << "\n";
}

void Parser::writeFooter()
{
    if (!stringsMap.empty())
    {
        out << "    ; strings\n";
        for(auto& i : stringsMap)
        {
            out << "s" << i.second << " db ";
            const char* s = i.first.c_str();
            const char* e = s + i.first.size() + 1;
            bool sm = false;
            bool f = true;
            for(; s != e; s++)
            {
                char c = *s;
                if ((unsigned char)c >= (unsigned char)' ' && c != '"')
                {
                    if (!sm)
                    {
                        if (!f) out << ",";
                        out << "\"";
                        sm = true;
                    }
                    out << c;
                }
                else
                {
                    if (sm) out << "\"";
                    sm = false;
                    if (!f) out << ",";
                    out << (unsigned)(unsigned char)c;
                }
                f = false;
            }
            if (sm) out << "\"";
            out << "\n";
        }
    }
}


inline void Parser::pushContinue(unsigned c)
{
    continues.push_back(c);
}

inline unsigned Parser::getContinue()
{
    if (continues.empty()) throw "Continue without loop";
    return continues.back();
}

inline void Parser::popContinue()
{
    if (continues.empty()) throw "Continue without loop";
    continues.pop_back();
}

inline void Parser::pushBreak(unsigned c)
{
    breaks.push_back(c);
}

inline unsigned Parser::getBreak()
{
    if (breaks.empty()) throw "Break without loop";
    return breaks.back();
}

inline void Parser::popBreak()
{
    if (breaks.empty()) throw "Break without loop";
    breaks.pop_back();
}

inline const char* Parser::getSubRegister(const std::string& reg, unsigned n)
{
    if (reg == "bc") return n == 0 ? "b" : "c";
    if (reg == "de") return n == 0 ? "d" : "e";
    if (reg == "hl") return n == 0 ? "h" : "l";
    if (reg == "ix") return n == 0 ? "ixh" : "ixl";
    if (reg == "iy") return n == 0 ? "iyh" : "iyl";
    throw (std::string)"Невозможно получить половину регистра " + reg;
}
