// Generated by Bisonc++ V6.01.00 on Wed, 13 Nov 2019 10:25:59 +0300

    // Include this file in the sources of the class Parser.

// $insert class.h
#include "Parser.h"
#include <limits.h>
#include "utf8tocp1251.h"
#include <sstream>

Parser::Parser(Scanner& scanner, std::ostream& out) : d_scanner(scanner), out(out)
{
    scanner.setSval(&d_val_, &consts, [&](unsigned line, const std::string& str) { nextLine(line, str); });
}

void Parser::error()
{
    throw("Syntax error");
}

// $insert lex
int Parser::lex()
{
    return d_scanner.lex();
}

void Parser::print()
{
    print_();           // displays tokens if --print was specified
}

void Parser::exceptionHandler(std::exception const &exc)
{
    throw;              // re-implement to handle exceptions thrown by actions
}

unsigned Parser::allocString(const std::string& str1)
{
    std::string str;
    if (!cp1251ToUtf8(str, str1)) throw("Unsupported unicode char");
    auto i = stringsMap.find(str);
    if (i != stringsMap.end()) return i->second;
    unsigned id = stringCounter++;
    stringsMap[str] = id;
    return id;
}

void Parser::nextLine(unsigned lineNr, const std::string& lineText)
{
    (void) lineNr;
    if (!lineText.empty())
        out << "    ; " << lineText << "\n";
}

void Parser::writeFooter()
{
    if (!stringsMap.empty())
    {
        out << "    ; strings\n";
        for(auto& i : stringsMap)
        {
            out << "s" << i.second << " db ";
            const char* s = i.first.c_str();
            const char* e = s + i.first.size() + 1;
            bool sm = false;
            bool f = true;
            for(; s != e; s++)
            {
                char c = *s;
                if ((unsigned char)c >= (unsigned char)' ' && c != '"')
                {
                    if (!sm)
                    {
                        if (!f) out << "\n db ";
                        out << "\"";
                        sm = true;
                    }
                    out << c;
                }
                else
                {
                    if (sm) out << "\"";
                    sm = false;
                    if (!f) out << "\n db ";
                    out << (unsigned)(unsigned char)c;
                }
                f = false;
            }
            if (sm) out << "\"";
            out << "\n";
        }
    }
}

std::string Parser::quoteString(const std::string& in)
{
    std::stringstream out;
    const char* s = in.c_str();
    const char* e = s + in.size() + 1;
    bool sm = false;
    bool f = true;
    for(; s != e; s++)
    {
        char c = *s;
        if ((unsigned char)c >= (unsigned char)' ' && c != '"')
        {
            if (!sm)
            {
                if (!f) out << ", ";
                out << "\"";
                sm = true;
            }
            out << c;
        }
        else
        {
            if (sm) out << "\"";
            sm = false;
            if (!f) out << ", ";
            out << (unsigned)(unsigned char)c;
        }
        f = false;
    }
    if (sm) out << "\"";
    return out.str();
}

// Строку в аргументы для инструкцию ассемблера db без терминатора

void Parser::quoteStringEx(std::vector<std::string>& outArray,  const std::string& in)
{
    const char* s = in.c_str();
    const char* e = s + in.size();
    for(; s != e; s++)
        outArray.push_back(std::to_string((unsigned char)*s));
}

inline void Parser::pushContinue(unsigned c)
{
    continues.push_back(c);
}

inline unsigned Parser::getContinue()
{
    if (continues.empty()) throw "Continue without loop";
    return continues.back();
}

inline void Parser::popContinue()
{
    if (continues.empty()) throw "Continue without loop";
    continues.pop_back();
}

inline void Parser::pushBreak(unsigned c)
{
    breaks.push_back(c);
}

inline unsigned Parser::getBreak()
{
    if (breaks.empty()) throw "Break without loop";
    return breaks.back();
}

inline void Parser::popBreak()
{
    if (breaks.empty()) throw "Break without loop";
    breaks.pop_back();
}

inline const char* Parser::getSubRegister(const std::string& reg, unsigned n)
{
    if (reg == "bc") return n == 0 ? "b" : "c";
    if (reg == "de") return n == 0 ? "d" : "e";
    if (reg == "hl") return n == 0 ? "h" : "l";
    if (reg == "ix") return n == 0 ? "ixh" : "ixl";
    if (reg == "iy") return n == 0 ? "iyh" : "iyl";
    throw (std::string)"Невозможно получить половину регистра " + reg;
}
